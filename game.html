<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Freeze Factory</title>
  <style>
    body {
      background-color: #222;
      color: #eee;
      font-family: 'Courier New', monospace;
      text-align: center;
      margin: 0;
      padding: 20px;
    }
    /* Layout: play area and log window side by side */
    #game-container {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      margin: 20px auto;
    }
    #play-area {
      position: relative;
    }
    #game-canvas {
      background-color: black;
      border: 2px solid #555;
    }
    /* Score panel positioned at top of play area */
    #score-panel {
      position: absolute;
      top: -20px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: space-around;
      font-size: 18px;
    }
    /* Scrolling log window on right side */
    #log-window {
      width: 200px;
      height: 550px; /* same height as canvas */
      background-color: #111;
      color: #0f0;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      overflow-y: auto;
      text-align: left;
      padding: 5px;
      margin-left: 10px;
    }
    /* Overlays */
    #welcome-screen, #game-over {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 24px;
      z-index: 1000;
    }
    /* Initially, welcome is visible; game-over is hidden */
    #welcome-screen { display: flex; }
    #game-over { display: none; }
    .hidden { display: none; }
    button {
      margin-top: 20px;
      padding: 10px 20px;
      background-color: #5f5;
      color: #000;
      border: none;
      border-radius: 5px;
      font-family: 'Courier New', monospace;
      font-size: 18px;
      cursor: pointer;
    }
    button:hover {
      background-color: #7f7;
    }
  </style>
</head>
<body>
  <h1>The Freeze Factory</h1>
  <div id="game-container">
    <div id="play-area">
      <canvas id="game-canvas" width="550" height="550"></canvas>
      <div id="score-panel">
        <div>Score: <span id="score">0</span></div>
        <div>Level: <span id="level">1</span></div>
        <div>Time: <span id="time">60</span></div>
        <div>Lives: <span id="lives">3</span></div>
      </div>
    </div>
    <div id="log-window"></div>
  </div>
  
  <!-- Overlays -->
  <div id="welcome-screen">
    <h2>Welcome to The Freeze Factory!</h2>
    <p>Use arrow keys or WASD to move</p>
    <p>Push ice blocks to trap or crush robots</p>
    <p>High Score: <span id="high-score">0</span></p>
    <button id="start-button">START GAME</button>
  </div>
  <div id="game-over">
    <h2>GAME OVER</h2>
    <p>Your score: <span id="final-score">0</span></p>
    <p>High Score: <span id="end-high-score">0</span></p>
    <button id="restart-button">PLAY AGAIN</button>
  </div>

  <script type="module">
 
  // WebLLM for operating LLMs in browser
	import * as webllm from 'https://esm.run/@mlc-ai/web-llm';

  // Create the MLCEngine instance
	const engine = new webllm.MLCEngine();
	const selectedModel = "Llama-3-8B-Instruct-q4f32_1-MLC-1k";

	// Start loading immediately; we'll await it later
	const loadModelPromise = engine.reload(selectedModel, {
		temperature: 0.8,
		top_p: 0.8
	}).then(() => {
		console.log('[LLM] Model loaded successfully');
	}).catch((err) => {
		console.error('[LLM] Failed to load model:', err);
	});
  
  document.addEventListener('DOMContentLoaded', async function() {
	  // Model loads in the background; game starts immediately with procedural AI
	  console.log('Game initialized and ready to play');

      // ----- GAME CONSTANTS -----
      const TILE_SIZE = 25;
      const GRID_WIDTH = 22;
      const GRID_HEIGHT = 22;
      const EMPTY = 0, WALL = 1, PLAYER = 2, ROBOT = 3, ICE = 4;
      const playerIsAI = false;  // Set to true to have LLM control the player
      
      // Configuration: player at top-left; robots in three other corners; maze of ice blocks.
      const ROBOT_COUNT = 3;
      const ICE_COUNT = 100;
      const FRICTION_DELAY = 150; // Delay before sliding begins
      const PUSH_THRESHOLD = 300; // Time required to push before ice slides
      let pushTimers = {}; // Track push timers per direction
      
      // ----- GAME VARIABLES -----
      let grid = [];
      let player = { x: 0, y: 0 };
      let robots = [];
      let score = 0, highScore = 0, level = 1, lives = 3, timeRemaining = 60;
      let gameInterval = null, timerInterval = null;
      let gameRunning = false;
      let collisionLock = false;
      
      // ----- DOM ELEMENTS -----
      const canvas = document.getElementById('game-canvas');
      const ctx = canvas.getContext('2d');
      const scoreDisplay = document.getElementById('score');
      const levelDisplay = document.getElementById('level');
      const timeDisplay = document.getElementById('time');
      const livesDisplay = document.getElementById('lives');
      const finalScoreDisplay = document.getElementById('final-score');
      const highScoreDisplay = document.getElementById('high-score');
      const endHighScoreDisplay = document.getElementById('end-high-score');
      const welcomeScreen = document.getElementById('welcome-screen');
      const gameOverScreen = document.getElementById('game-over');
      const startButton = document.getElementById('start-button');
      const restartButton = document.getElementById('restart-button');
      const logWindow = document.getElementById('log-window');

      // ----- COLORS -----
      const COLORS = {
        empty: 'black',
        wall: '#555',
        player: '#5f5',
        robot: '#f55',
        ice: '#5ff'
      };

      // ----- Logging Function -----
      function addLog(message) {
        const p = document.createElement('p');
        p.textContent = message;
        logWindow.appendChild(p);
        logWindow.scrollTop = logWindow.scrollHeight;
      }
	  
      // ----- AI testing -----
	  async function promptAI(promptText) {
		  // ensure the model is ready
		  await loadModelPromise;
		  
          try {
			// generate a completion using WebLLM's chat API
			addLog(`[Prompt] ${promptText}`);
			
			const messages = [
				{ role: "user", content: promptText }
			];
			
			const completion = await engine.chat.completions.create({
				messages: messages,
				max_tokens: 20,
				temperature: 0.8,
				top_p: 0.8
			});
			
			const responseText = completion.choices[0].message.content.trim();
			
			// write it out to your log window
			addLog(`[LLM] ${responseText}`);
			return responseText;
		  } catch (err) {
			console.error("LLM call failed:", err);
			addLog("[LLM] <error> " + err.message);
			return null;
		  }
	  }
	  
	  //try {
	  //		await promptAI("Calculate 2+2 = ");
	  //	  } catch(e) {
	  //	console.error("Worker call failed:", e);
	  //	  }
	  
      // ----- AI logic -----
	  
		// Extract a 7×7 local view around robot
		function extractContext(robot) {
		  const R = 3;
		  let map = '';
		  for (let dy = -R; dy <= R; dy++) {
			for (let dx = -R; dx <= R; dx++) {
			  const x = robot.x + dx, y = robot.y + dy;
			  let c = 'W';
			  if (x>=0 && x<GRID_WIDTH && y>=0 && y<GRID_HEIGHT) {
				const v = grid[y][x];
				c = v===EMPTY?'.': v===WALL?'W': v===ICE?'I': (v===PLAYER?'P': v===ROBOT?'R':'.');
			  }
			  map += c;
			}
			map += '\n';
		  }
		  return map;
		}

		// Build a short prompt asking for 2–6 moves
		function buildPlanPrompt(robot) {
		  const lm = extractContext(robot);
		  return `You are robot ${robot.id} role=${robot.role}.`
			+ ` Map:\n${lm}`
			+ ` You at (${robot.x},${robot.y}), P at (${player.x},${player.y}).`
			+ ` Return only JSON: {"plan":["UP",...]} with 2-6 moves.`;
		}
		
		// Generate a micro-plan and enqueue moves
		async function generateMovePlan(robot) {
		  const prompt = buildPlanPrompt(robot);
		  
		  addLog("Prompt for robot (" + robot.id + "): " + prompt);
		  
		  const params = { nPredict: 10, sampling: { temp:0.8, top_p:0.8 } };
		  let txt;
		  try {
			txt = await wllama.createCompletion(prompt, params);
			const obj = JSON.parse(txt);
			robot.moveQueue = obj.plan || [];
			addLog(`robot ${robot.id} plan: ${robot.moveQueue.join(',')}`);
		  } catch(e) {
			robot.moveQueue = [];
			addLog(`robot ${robot.id} plan err`);
		  }
		}

		// Alias your old procedural updater
		const updateRobotProcedural = updateRobot;

		// Replace your AI updater with this:
		async function updateRobotAI(robot) {
		  if (!gameRunning) return;
		
		  // 1) If we’ve run out of moves, ask the LLM for another micro-plan
		  if (!robot.moveQueue || robot.moveQueue.length === 0) {
			await generateMovePlan(robot);
		  }

		  // 2) If still no plan (e.g. on LLM error), fall back to greedy chase
		  if (!robot.moveQueue || robot.moveQueue.length === 0) {
			updateRobotProcedural(robot);
			return;
		  }

		  // 3) Consume the next move
		  const dir = robot.moveQueue.shift();
		  const M = { 
			UP:    { dx: 0,  dy: -1 }, 
			DOWN:  { dx: 0,  dy:  1 }, 
			LEFT:  { dx: -1, dy:  0 }, 
			RIGHT: { dx: 1,  dy:  0 } 
		  }[dir];

		  const moved = tryMoveRobot(robot, M.dx, M.dy);

		  // 4) If blocked, dump the rest of the plan and revert to procedural
		  if (!moved) {
			robot.moveQueue = [];
			updateRobotProcedural(robot);
		  }
		}

		
      // ----- initGame() -----
      // Sets up the game board: grid, walls, player, robots, and ice blocks.
      function initGame() {
        grid = Array.from({ length: GRID_HEIGHT }, () => Array(GRID_WIDTH).fill(EMPTY));
        // Build walls around edges.
        for (let x = 0; x < GRID_WIDTH; x++) {
          grid[0][x] = WALL;
          grid[GRID_HEIGHT - 1][x] = WALL;
        }
        for (let y = 0; y < GRID_HEIGHT; y++) {
          grid[y][0] = WALL;
          grid[y][GRID_WIDTH - 1] = WALL;
        }
        // Place player in top-left (cell [1,1]).
        player.x = 1;
        player.y = 1;
        grid[player.y][player.x] = PLAYER;
        // Place robots in three other corners.
        robots = [];
        const corners = [
          { x: GRID_WIDTH - 2, y: 1 },            // top-right
          { x: 1, y: GRID_HEIGHT - 2 },           // bottom-left
          { x: GRID_WIDTH - 2, y: GRID_HEIGHT - 2 } // bottom-right
        ];
        for (let i = 0; i < ROBOT_COUNT; i++) {
          const pos = corners[i];
          robots.push({ x: pos.x, y: pos.y });
          grid[pos.y][pos.x] = ROBOT;
        }
        // Randomly place ice blocks (avoid edges).
        let placedIce = 0;
        while (placedIce < ICE_COUNT) {
          const ix = Math.floor(Math.random() * (GRID_WIDTH - 2)) + 1;
          const iy = Math.floor(Math.random() * (GRID_HEIGHT - 2)) + 1;
          if (grid[iy][ix] === EMPTY) {
            grid[iy][ix] = ICE;
            placedIce++;
          }
        }
        if (level === 1) score = 0;
        timeRemaining = 60;
        updateDisplays();
        render();
        addLog("Game initialized.");
      }

      // ----- Update HUD -----
      function updateDisplays() {
        scoreDisplay.textContent = score;
        levelDisplay.textContent = level;
        timeDisplay.textContent = timeRemaining;
        livesDisplay.textContent = lives;
        highScoreDisplay.textContent = highScore;
        endHighScoreDisplay.textContent = highScore;
      }

      // ----- Render the Grid -----
      function render() {
        if (!grid || grid.length !== GRID_HEIGHT) {
          console.log("Grid not ready for render.");
          return;
        }
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (let y = 0; y < GRID_HEIGHT; y++) {
          for (let x = 0; x < GRID_WIDTH; x++) {
            const cell = grid[y][x];
            if (cell !== EMPTY) {
              ctx.fillStyle = COLORS[
                cell === WALL ? 'wall' :
                cell === PLAYER ? 'player' :
                cell === ROBOT ? 'robot' : 'ice'
              ];
              ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
              if (cell === PLAYER) {
                ctx.fillStyle = 'black';
                ctx.fillRect(x * TILE_SIZE + 7, y * TILE_SIZE + 8, 3, 3);
                ctx.fillRect(x * TILE_SIZE + 15, y * TILE_SIZE + 8, 3, 3);
                ctx.fillRect(x * TILE_SIZE + 7, y * TILE_SIZE + 16, 11, 2);
              } else if (cell === ROBOT) {
                ctx.fillStyle = 'white';
                ctx.fillRect(x * TILE_SIZE + 6, y * TILE_SIZE + 7, 4, 4);
                ctx.fillRect(x * TILE_SIZE + 15, y * TILE_SIZE + 7, 4, 4);
                ctx.fillRect(x * TILE_SIZE + 8, y * TILE_SIZE + 16, 9, 2);
              } else if (cell === ICE) {
                ctx.fillStyle = 'white';
                ctx.fillRect(x * TILE_SIZE + 5, y * TILE_SIZE + 5, 2, 2);
                ctx.fillRect(x * TILE_SIZE + 15, y * TILE_SIZE + 8, 2, 2);
                ctx.fillRect(x * TILE_SIZE + 10, y * TILE_SIZE + 15, 2, 2);
              }
            }
          }
        }
      }
	  
	// ----- Compute Slide Path -----
	// Computes the full path for an ice block pushed from (x,y) in direction (dx,dy).
	// If the ice block encounters a wall or goes out-of-bounds, it stops.
	// If it encounters a robot, it returns type "crush".
	// If it encounters another ice block, it stops sliding (returns type "slide").
	// Returns an object: { path: [ {x, y}, ... ], type: "slide" | "crush" }
	function computeSlidePath(x, y, dx, dy) {
	  let path = [];
	  let curX = x, curY = y;
	  while (true) {
		let nextX = curX + dx, nextY = curY + dy;
		// If next cell is out-of-bounds or a wall, end the slide.
		if (nextX < 0 || nextX >= GRID_WIDTH || nextY < 0 || nextY >= GRID_HEIGHT) {
			path.push({ x: curX, y: curY });
			return { path: path, type: "slide" };		  
		}
		// If next cell is empty, add it to the path and continue.
		if (grid[nextY][nextX] === EMPTY) {
		  path.push({ x: nextX, y: nextY });
		  curX = nextX;
		  curY = nextY;
		  continue;
		}
		// If next cell is a robot, add that cell and return a "crush" event.
		if (grid[nextY][nextX] === ROBOT) {
		  path.push({ x: nextX, y: nextY });
		  return { path: path, type: "crush" };
		}
		// If next cell is another ice block, then stop sliding here.
		if (grid[nextY][nextX] === ICE || grid[nextY][nextX] === WALL) {
          if (path.length === 0)
			return { path: path, type: "melt" };
		  else
			return { path: path, type: "slide" };
		}
		break;
	  }
	  return { path: path, type: "slide" };
	}
	  
  // ----- Animate Slide -----
  function animateSlide(path, slideResult, callback) {
    let i = 0;
    function step() {
      if (i < path.length) {
        let pos = path[i];
        if (i > 0) {
          let prev = path[i - 1];
          if (grid[prev.y][prev.x] === ICE) grid[prev.y][prev.x] = EMPTY;
        }
        grid[pos.y][pos.x] = ICE;
        render();
        i++;
        setTimeout(step, 50);
      } else {
        callback(slideResult);
      }
    }
    step();
  }

	// ----- Slide Ice with Friction Delay -----
	function slideIceDelayed(x, y, dx, dy) {
	
	  grid[y][x] = EMPTY;

	  setTimeout(() => {
		let result = computeSlidePath(x, y, dx, dy);
				
		// Start the slide animation; animateSlide() will clear the original cell on its first step.
		animateSlide(result.path, result, function(finalResult) {
		  if (finalResult.type === "slide") {
			let finalPos = finalResult.path[finalResult.path.length - 1];
			//addLog("Ice block slid to (" + finalPos.x + "," + finalPos.y + ").");
			grid[finalPos.y][finalPos.x] = ICE;
		  } else if (finalResult.type === "crush") {
			let crushPos = finalResult.path[finalResult.path.length - 1];
			addLog("Ice block crushed a robot at (" + crushPos.x + "," + crushPos.y + ").");
			grid[crushPos.y][crushPos.x] = ICE;
			score += 100;
			updateDisplays();
			scheduleRobotRevival(crushPos.x, crushPos.y);
		  } else if (finalResult.type === "melt") {
			addLog("Ice block melted away.");
		  }
		  render();
		});
	  }, FRICTION_DELAY);
	  return computeSlidePath(x, y, dx, dy);
	}

    // ----- Modular Player Action -----
    function playerAct(direction) {
      let dx = 0, dy = 0;
      switch(direction) {
        case "UP": dy = -1; break;
        case "DOWN": dy = 1; break;
        case "LEFT": dx = -1; break;
        case "RIGHT": dx = 1; break;
        default: return false;
      }
      return movePlayer(dx, dy);
    }

    // ----- PLAYER MOVEMENT -----
  function movePlayer(dx, dy) {
    const newX = player.x + dx;
    const newY = player.y + dy;

    if (newX < 0 || newX >= GRID_WIDTH || newY < 0 || newY >= GRID_HEIGHT) {
      return false;
    }

    if (grid[newY][newX] === EMPTY) {
      grid[player.y][player.x] = EMPTY;
      player.x = newX;
      player.y = newY;
      grid[player.y][player.x] = PLAYER;
      return true;
    } else if (grid[newY][newX] === ICE) {
      // Unique key for push tracking
      let pushKey = `${newX},${newY},${dx},${dy}`;

      // If this is a new push, start a timer
      if (!pushTimers[pushKey]) {
        pushTimers[pushKey] = setTimeout(() => {
          slideIceDelayed(newX, newY, dx, dy);
          delete pushTimers[pushKey];  // Clear after execution
        }, PUSH_THRESHOLD);
      }
      return true;
    }

    return false;
  }

  // Cancel push timers if the player moves away or stops pushing
  function cancelPushTimers() {
    for (let key in pushTimers) {
      clearTimeout(pushTimers[key]);
    }
    pushTimers = {};
  }
	  	  
    // ----- ROBOT MOVEMENT -----
    function tryMoveRobot(robot, dx, dy) {
      const newX = robot.x + dx;
      const newY = robot.y + dy;
      if (newX < 0 || newX >= GRID_WIDTH || newY < 0 || newY >= GRID_HEIGHT) {
        return false;
      }
      if (grid[newY][newX] === EMPTY) {
        grid[robot.y][robot.x] = EMPTY;
        robot.x = newX;
        robot.y = newY;
        grid[newY][newX] = ROBOT;
        return true;
      } else if (grid[newY][newX] === PLAYER) {
        addLog("Robot collided with player at (" + newX + "," + newY + ").");
        if (gameRunning) playerCaught();
        return true;
      }
      return false;
    }

    // ----- Update a Single Robot (modular guidance) -----
    function updateRobot(robot) {
      const dx = Math.sign(player.x - robot.x);
      const dy = Math.sign(player.y - robot.y);

		// Try to move the robot towards the player
		let moved = false;
        if (Math.abs(player.x - robot.x) > Math.abs(player.y - robot.y)) {
          moved = tryMoveRobot(robot, dx, 0) || tryMoveRobot(robot, 0, dy);
        } else {
          moved = tryMoveRobot(robot, 0, dy) || tryMoveRobot(robot, dx, 0);
        }
		
		// The robot cannot move towards the player and is moving randomly instead
    if (!moved) {
      const directions = [
        { dx: 1, dy: 0 },
        { dx: -1, dy: 0 },
        { dx: 0, dy: 1 },
        { dx: 0, dy: -1 }
      ];
      directions.sort(() => Math.random() - 0.5);
      for (const dir of directions) {
        if (tryMoveRobot(robot, dir.dx, dir.dy)) {
          //addLog("Robot at (" + robot.x + "," + robot.y + ") could not move towards the player and moved randomly instead.");
          break;
        }
      }
    }
  
      if (robot.x === player.x && robot.y === player.y) {
        if (gameRunning && !collisionLock) {
          collisionLock = true;
          playerCaught();
          setTimeout(() => { collisionLock = false; }, 100);
        }
      }
    }

      // ----- Move All Robots -----
      function moveRobots() {
        if (!gameRunning) return;

        // Update each robot uniquely
        for (const robot of robots) {
          updateRobot(robot);
        }
      }
      // ----- PLAYER CAUGHT -----
      function playerCaught() {
        if (!gameRunning) return;
        addLog("Player caught");
        lives--;
        updateDisplays();
        if (lives <= 0) {
          endGame();
        } else {
          resetPositions();
        }
      }

      // ----- RESET POSITIONS -----
      function resetPositions() {
        addLog("Resetting positions");
        grid[player.y][player.x] = EMPTY;
        for (const robot of robots) {
          grid[robot.y][robot.x] = EMPTY;
        }
        // Place player in top-left.
        player.x = 1;
        player.y = 1;
        grid[player.y][player.x] = PLAYER;
        robots = [];
        const corners = [
          { x: GRID_WIDTH - 2, y: 1 },
          { x: 1, y: GRID_HEIGHT - 2 },
          { x: GRID_WIDTH - 2, y: GRID_HEIGHT - 2 }
        ];
        for (let i = 0; i < ROBOT_COUNT; i++) {
          const pos = corners[i];
          robots.push({ x: pos.x, y: pos.y });
          grid[pos.y][pos.x] = ROBOT;
        }
        render();
      }

      // ----- LEVEL COMPLETE -----
      function levelComplete() {
        addLog("Level complete");
        score += timeRemaining * 10;
        level++;
        updateDisplays();
        initGame();
      }

      // ----- (Disabled) TIMER -----
      function updateTimer() {
        timeDisplay.textContent = timeRemaining;
        if (timeRemaining <= 0) {
          playerCaught();
        }
      }

      // ----- END GAME -----
      function endGame() {
        addLog("Game over");
        clearInterval(gameInterval);
        clearInterval(timerInterval);
        if (score > highScore) {
          highScore = score;
          highScoreDisplay.textContent = highScore;
          endHighScoreDisplay.textContent = highScore;
        }
        finalScoreDisplay.textContent = score;
        gameOverScreen.classList.remove('hidden');
        gameOverScreen.style.display = "flex";
        gameRunning = false;
      }

      // ----- START GAME -----
      function startGame() {
        // Hide overlays
        welcomeScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
		
        welcomeScreen.style.display = "none";
        gameOverScreen.style.display = "none";
        
        score = 0;
        level = 1;
        lives = 3;
        timeRemaining = 60;
        
        initGame();
        
        // Main game loop for robot movement
        gameInterval = setInterval(() => {
          moveRobots();
          render();
        }, 800);
        
        gameRunning = true;
        collisionLock = false;
        addLog("Game started");
      }

      // ----- RESTART GAME -----
      function restartGame() {
        gameOverScreen.classList.add('hidden');
        gameOverScreen.style.display = "none";
        startGame();
      }

      // ----- KEY LISTENER -----
      document.addEventListener('keydown', (e) => {
        if (!gameRunning) return;
        if (playerIsAI) return;
        let action = null;
        switch(e.key) {
          case 'ArrowUp':
          case 'w':
          case 'W':
            action = "UP";
            break;
          case 'ArrowDown':
          case 's':
          case 'S':
            action = "DOWN";
            break;
          case 'ArrowLeft':
          case 'a':
          case 'A':
            action = "LEFT";
            break;
          case 'ArrowRight':
          case 'd':
          case 'D':
            action = "RIGHT";
            break;
        }
        if (action) {
          if (playerAct(action)) {
            //addLog("Player moved " + action + " to (" + player.x + "," + player.y + ").");
            //console.log("Player moved to:", player);
            render();
          }
        }
      });

  	  // Listen for key releases to cancel ice pushing if the player stops pressing
	  document.addEventListener('keyup', (e) => {
		cancelPushTimers();  // Stop all ice push attempts
	  });

      startButton.addEventListener('click', () => {
        startGame();
      });
      restartButton.addEventListener('click', () => {
        restartGame();
      });

      addLog("Game ready");
    });
  </script>
</body>
</html>
